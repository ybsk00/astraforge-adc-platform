# 실데이터 기반 Golden Set(ADC) 100 자동 적재 구현안 (ClinicalTrials.gov v2 + (옵션) PubMed)

## 0. 목표
- Mock 없이 **실데이터**로 Golden Candidates 100개를 매 실행(run)마다 생성
- 후보 단위는 1차적으로 **Trial(NCT) 단위**로 고정(= 100개 보장)
- 구성요소(Target/Antibody/Linker/Payload)는 “추출 성공 시 채움”, 실패 시 Unknown 허용(단, 리뷰 플래그로 구분)
- 중복은 2단계로 처리
  - **NCT 중복(동일 trial)**: 제거(필수)
  - **조합/프로그램 중복**: 삭제하지 말고 `program_key`로 그룹핑(권장)

---

## 1. 데이터 소스 / 정책
### 1.1 ClinicalTrials.gov v2 API (필수)
- 목적: NCT 후보 100개 수집 + trial 메타데이터 + references(가능하면 PMID) 확보
- API Key: 필요 없음(공개 API)
- 주의: rate limit 존재 → 워커에서 sleep/캐시 적용

### 1.2 PubMed E-utilities (옵션, 보강용)
- 목적: ClinicalTrials에 PMID가 없을 때만 추가 근거 확보
- API Key: 선택(있으면 rate limit 완화)
- 최소 구현에서는 “ClinicalTrials referencesModule”만으로도 Evidence UI 구현 가능

---

## 2. DB 스키마/인덱스 (필수/권장)
> 현재 목표는 “NCT 단위로 100개를 확정 생성”이므로, 후보 유니크 키는 **(golden_set_id, source_ref=NCT)** 가 되어야 합니다.

### 2.1 필수: golden_candidates 유니크 인덱스 교체
```sql
-- 기존 인덱스 제거(이름은 실제 적용된 이름으로)
drop index if exists public.golden_candidates_unique_key;

-- NCT 단위로 set 내 중복 방지
create unique index public.golden_candidates_unique_key
on public.golden_candidates (golden_set_id, source_ref);
2.2 권장: program_key 컬럼/인덱스 (조합 중복을 “그룹핑”으로 처리)
sql
코드 복사
alter table public.golden_candidates
add column if not exists program_key text;

create index if not exists golden_candidates_program_key_idx
on public.golden_candidates (program_key);
2.3 권장: evidence 중복 방지
sql
코드 복사
create unique index if not exists golden_candidate_evidence_unique_key
on public.golden_candidate_evidence (candidate_id, source, ref_id);
3. 커넥터 Config (실데이터 모드)
3.1 connectors.config 예시
json
코드 복사
{
  "target_count": 100,
  "min_score": 30,
  "min_evidence": 1,

  "data_source": "clinicaltrials",
  "clinicaltrials": {
    "page_size": 100,
    "max_pages_per_query": 10,
    "sleep_sec": 1.3,

    "queries": [
      { "query.term": "\"antibody-drug conjugate\" OR \"antibody drug conjugate\" OR ADC" },
      { "query.intr": "vedotin OR deruxtecan OR govitecan OR soravtansine OR ozogamicin" },
      { "query.term": "MMAE OR DM1 OR DM4 OR DXd OR SN-38 OR calicheamicin" }
    ],

    "filters": {
      "filter.overallStatus": "RECRUITING,ACTIVE_NOT_RECRUITING,COMPLETED"
    },
    "sort": "LastUpdatePostDate:desc"
  },

  "pubmed": {
    "enabled": true,
    "api_key_env": "NCBI_API_KEY",
    "email_env": "NCBI_EMAIL",
    "sleep_sec": 0.4,
    "max_pmids_per_candidate": 3
  }
}
4. 워커 구현(핵심 로직)
4.1 전체 파이프라인
Create Golden Set Version

golden_sets에 (name, version, config) upsert 후 golden_set_id 확보

version은 run마다 timestamp 포함

Fetch NCT 후보 리스트 (ClinicalTrials Search API)

config.queries를 순회하면서 /api/v2/studies를 호출

페이징하며 target_count 만큼의 유니크 NCT를 확보

Raw 단계 Dedup: seen_ncts로 NCT 중복 제거

Fetch Study Details (NCT별 상세)

/api/v2/studies/{NCT_ID} 호출

필요한 필드만 추출해서 raw_source로 저장(너무 큰 JSON은 요약 저장 권장)

Extract & Normalize (구성요소 추출)

입력 텍스트 소스(우선순위):

title(official/brief) + intervention name + conditions + keywords(있으면)

추출 규칙:

Target: TARGET_DICTIONARY + 정규식(HER2/HER3/TROP2/EGFR/BCMA 등)

Payload/Linker: suffix heuristic + PAYLOAD_DICTIONARY/LINKER_DICTIONARY

Antibody: drug_name 첫 토큰(예: trastuzumab) + 사전 매핑(있으면)

Evidence 구성

1차: ClinicalTrials의 referencesModule에서 PMID/논문 링크가 있으면 이를 Evidence로 사용

2차(옵션): PubMed ESearch로 보강 (NCT ID 또는 drug_name 기반)

evidence 저장:

golden_candidates.evidence_json에 요약(출처 리스트/스니펫/추출 근거)

golden_candidate_evidence에는 정규화된 레코드로 insert

Scoring & Gate

Trial 단위 100개 확보가 목적이므로 “4요소 완비”를 Hard Gate로 두지 않음

최소 게이트(권장):

source_ref(NCT) 존재

title 존재

score >= min_score(기본 30)

추출 실패 항목은 review_status = "needs_enrichment"로 분리

Upsert (중복 방지)

on_conflict="golden_set_id,source_ref" 로 upsert

program_key는 조합 중복 그룹핑용으로 계산해 저장

Evidence table은 unique index로 중복 insert 방지

5. ClinicalTrials API 호출 스펙(구현 지침)
5.1 Search
GET https://clinicaltrials.gov/api/v2/studies

params 예:

query.term 또는 query.intr

filter.overallStatus

sort

pageSize

pageToken(페이징)

fields(가능하면 최소 필드로 줄여 대역폭 절감)

5.2 Study Details
GET https://clinicaltrials.gov/api/v2/studies/{NCT_ID}

응답에서 주요 모듈만 사용:

identificationModule: nctId, titles

statusModule: overallStatus, dates

conditionsModule: conditions

armsInterventionsModule(또는 designModule 계열): interventions

referencesModule: 관련 논문/PMID

6. 중복 정책(필수)
6.1 NCT 중복(필수 제거)
Raw fetch 단계에서 seen_ncts로 제거

DB에서 unique(golden_set_id, source_ref)로 최종 차단

6.2 조합 중복(삭제 금지, 그룹핑)
program_key = sha1(drug_name|target|antibody|linker|payload) 저장

UI에서는 program_key 기준 그룹핑:

기본 화면: 고유 program 목록 + “trial N개” 배지

펼치기: NCT 리스트/근거 모달

7. 검증 SQL (성공 판정)
sql
코드 복사
-- 1) set별 후보 수(목표: 최신 set = 100)
select golden_set_id, count(*)
from public.golden_candidates
group by golden_set_id
order by count(*) desc;

-- 2) 동일 set 내 NCT 중복 여부(목표: 100 = 100)
select count(*) as total, count(distinct source_ref) as distinct_nct
from public.golden_candidates
where golden_set_id = '<LATEST_GOLDEN_SET_ID>';

-- 3) 표적 다양성(현실적으로 점진 개선)
select count(distinct target) as n_targets
from public.golden_candidates
where golden_set_id = '<LATEST_GOLDEN_SET_ID>';

-- 4) 조합 중복 그룹핑 확인
select program_key, count(*) as n_trials
from public.golden_candidates
where golden_set_id = '<LATEST_GOLDEN_SET_ID>'
group by program_key
order by n_trials desc
limit 20;
8. 운영 권장값(초기)
min_evidence=1, min_score=30로 시작 → 파이프라인 안정화 후 상향

Unknown 비율이 높은 구간은 정상(추출 로직을 점진 개선)

“HER2/HER3 유명 표적”은 실데이터 유입 후 target 추출(사전/정규식) 개선으로 빠르게 반영 가능

9. 구현 체크리스트(바로 적용)
 DB 인덱스: unique(golden_set_id, source_ref) 적용

 program_key 컬럼/인덱스 추가

 worker: clinicaltrials fetch + paging + sleep + NCT dedup 적용

 details fetch에서 interventions/conditions/references 추출

 evidence_json + golden_candidate_evidence insert 연결

 UI: program_key 그룹핑 + Evidence 모달(기존 요구사항)

markdown
코드 복사
