# ADC 플랫폼 Admin Dashboard + DB/Backend 연동 구현계획안 (상세 버전)

> 목표: 현재 Admin 메뉴(커넥터/스테이징/데이터 수집/관측성/알림)를 “실제 운영 가능한 시스템”으로 완성하고, 추가 메뉴(대시보드/Runs/리포트/카탈로그/정규화/평가/권한/비용/감사로그)를 **DB + FastAPI 백엔드**와 완전 연동한다.  
> 전제: 모든 API는 `/api/v1` 프리픽스 사용. (Frontend Next.js ↔ Backend FastAPI Engine)  
> 핵심 산출물: (1) 정형 DB 스키마, (2) 백엔드 API, (3) 워커/잡(수집·인덱싱·오케스트레이션·PDF), (4) Admin UI 리스트/상세/액션 연동.

---

## 0. 시스템 구성(권장)

### 0.1 컴포넌트
- **Frontend**: Next.js (Admin UI)
- **Backend**: FastAPI Engine (`/api/v1`)
- **DB**: PostgreSQL (권장: Supabase/Postgres 동일)
- **Vector Store**: pgvector (동일 DB 확장 사용)
- **Object Storage**: S3 또는 Supabase Storage (PDF/아티팩트 저장)
- **Queue/Worker**: Redis + RQ/Celery/Arq 중 택1 (권장: RQ 또는 Celery)
- **Observability**: OpenTelemetry + Prometheus/Grafana + Sentry (또는 최소 로그/메트릭 테이블)

### 0.2 핵심 데이터 흐름
1) Seed/카탈로그 입력(관리자)  
2) 커넥터 실행 → 스테이징 적재 → 정규화/엔티티 리졸브 → 인덱싱(pgvector)  
3) 설계 Run 생성(오케스트레이터) → Evidence 수집(RAG) → Report JSON 생성 → PDF 렌더 → 저장/다운로드  
4) 관측성/알림/감사로그에 모두 기록

---

## 1. DB 스키마 설계 (PostgreSQL)

> 원칙: “운영 상태(잡/런/오류)”와 “도메인 데이터(카탈로그/문헌/엔티티)”를 분리하고, 모든 변경은 **audit_logs**로 추적한다.

### 1.1 공통 테이블

#### `users`
- `id` (uuid, pk)
- `email` (text, unique)
- `name` (text)
- `created_at` (timestamptz)

#### `roles`
- `id` (uuid, pk)
- `name` (text, unique)  // admin, analyst, viewer 등

#### `user_roles`
- `user_id` (uuid, fk -> users.id)
- `role_id` (uuid, fk -> roles.id)
- pk(`user_id`,`role_id`)

#### `audit_logs`
- `id` (bigserial, pk)
- `actor_user_id` (uuid, nullable)
- `action` (text)  // CREATE/UPDATE/DELETE/EXECUTE/RETRY/DOWNLOAD 등
- `entity_type` (text)  // connector, run, template, catalog_item 등
- `entity_id` (text)    // uuid 또는 복합키 문자열
- `before_json` (jsonb)
- `after_json` (jsonb)
- `created_at` (timestamptz, default now())

**인덱스**
- `audit_logs(entity_type, created_at desc)`
- `audit_logs(actor_user_id, created_at desc)`

---

### 1.2 커넥터/수집 파이프라인

#### `connectors`
- `id` (uuid, pk)
- `name` (text)  // PubMed, ClinicalTrials, Patents 등
- `type` (text)  // api, crawler, file_import
- `is_enabled` (bool, default true)
- `config_json` (jsonb) // base_url, rate_limit, parsing rules 등
- `created_at`, `updated_at`

#### `connector_runs`  (커넥터 실행 이력)
- `id` (uuid, pk)
- `connector_id` (uuid, fk)
- `status` (text) // queued, running, succeeded, failed, cancelled
- `started_at`, `ended_at`
- `input_json` (jsonb)   // seed, query, params
- `stats_json` (jsonb)   // fetched_count, parsed_count, stored_count
- `error_json` (jsonb)   // stack, message, retriable, http_code 등
- `created_at`

**인덱스**
- `connector_runs(connector_id, created_at desc)`
- `connector_runs(status, created_at desc)`

#### `staging_documents`
- `id` (uuid, pk)
- `connector_run_id` (uuid, fk)
- `source_type` (text) // pubmed, trial, patent, web
- `source_uid` (text)  // PMID, NCT, patent_no, url hash 등
- `raw_json` (jsonb)   // 원문/메타
- `raw_text` (text)    // 추출 텍스트 (가능하면)
- `status` (text)      // staged, parsed, normalized, rejected
- `reject_reason` (text, nullable)
- `created_at`

**인덱스**
- unique(`source_type`,`source_uid`)
- `staging_documents(status, created_at desc)`

---

### 1.3 정규화/엔티티/코퍼스

#### `entities` (도메인 엔티티 공통 저장소)
- `id` (uuid, pk)
- `entity_type` (text) // target, antibody, linker, payload, indication, gene 등
- `canonical_name` (text)
- `synonyms` (text[])  // 또는 별도 테이블로 분리 가능
- `attributes_json` (jsonb) // payload_class, linker_type, etc
- `created_at`, `updated_at`

**인덱스**
- `entities(entity_type, canonical_name)`
- GIN index on `synonyms`(선택)

#### `normalization_rules`
- `id` (uuid, pk)
- `rule_type` (text) // synonym_map, regex, whitelist, blacklist, classifier_hint
- `pattern` (text)
- `replacement` (text)
- `priority` (int)
- `is_enabled` (bool)
- `created_at`, `updated_at`

#### `corpus_documents` (정규화 완료된 문헌/자료 메타)
- `id` (uuid, pk)
- `source_type` (text)
- `source_uid` (text)
- `title` (text)
- `abstract` (text)
- `published_at` (date, nullable)
- `doi` (text, nullable)
- `url` (text, nullable)
- `metadata_json` (jsonb)
- `created_at`

**인덱스**
- unique(`source_type`,`source_uid`)
- `corpus_documents(published_at desc)`

#### `corpus_chunks` (청킹 + 임베딩)
- `id` (uuid, pk)
- `document_id` (uuid, fk -> corpus_documents.id)
- `chunk_index` (int)
- `text` (text)
- `token_count` (int)
- `embedding` (vector) // pgvector
- `meta_json` (jsonb)  // section, offsets 등
- `created_at`

**인덱스**
- `corpus_chunks(document_id, chunk_index)`
- vector index (ivfflat/hnsw) on `embedding` (환경에 맞게 선택)

---

### 1.4 설계 Run / 오케스트레이터 / 보고서

#### `design_runs`
- `id` (uuid, pk)
- `run_type` (text) // adc_candidate_report, target_selection_report, risk_review_report, experiment_plan_report
- `status` (text)   // queued, retrieving, structuring, writing, qa, rendering, done, failed, cancelled
- `created_by` (uuid, fk -> users.id)
- `input_json` (jsonb) // target/indication/constraints/report options
- `progress` (int) // 0-100
- `error_json` (jsonb)
- `created_at`, `updated_at`, `completed_at`

**인덱스**
- `design_runs(status, created_at desc)`
- `design_runs(created_by, created_at desc)`

#### `run_steps` (단계별 로그/산출물)
- `id` (uuid, pk)
- `run_id` (uuid, fk)
- `step_name` (text) // evidence_harvest, structuring_scoring, composition, qa, pdf_render
- `status` (text)    // started, succeeded, failed
- `started_at`, `ended_at`
- `metrics_json` (jsonb) // evidence_count, claims_count 등
- `error_json` (jsonb)

#### `evidences`
- `id` (uuid, pk)
- `run_id` (uuid, fk)
- `evidence_id` (text) // E-000123 형태
- `source_document_id` (uuid, fk -> corpus_documents.id, nullable)
- `citation` (text)    // doi/pmid 등
- `excerpt` (text)     // 1~3 문장 발췌(저작권 고려)
- `location` (text)    // section/figure/table/offset
- `confidence` (numeric)
- `meta_json` (jsonb)
- `created_at`

**인덱스**
- `evidences(run_id, evidence_id)`
- `evidences(source_document_id)`

#### `reports`
- `id` (uuid, pk)
- `run_id` (uuid, fk)
- `report_json` (jsonb)  // 최종 Report JSON
- `claim_evidence_rate` (numeric)
- `assumption_count` (int)
- `created_at`

#### `report_artifacts`
- `id` (uuid, pk)
- `run_id` (uuid, fk)
- `artifact_type` (text) // pdf, html, figure, table, log
- `storage_path` (text)  // s3://... 또는 supabase storage path
- `content_type` (text)
- `size_bytes` (bigint)
- `created_at`

---

### 1.5 리포트 템플릿

#### `report_templates`
- `id` (uuid, pk)
- `template_name` (text)
- `run_type` (text)
- `version` (text) // v1.0.0
- `template_json` (jsonb) // 섹션 구성, 표 규칙, Evidence Index 규칙
- `is_active` (bool)
- `created_at`, `updated_at`

**인덱스**
- unique(`run_type`,`version`)
- `report_templates(run_type, is_active)`

---

### 1.6 관측성/알림

#### `metrics_timeseries` (최소 운영형)
- `id` (bigserial, pk)
- `metric_name` (text) // run_success_rate, ingestion_count, embedding_latency_p95 등
- `tags_json` (jsonb)  // {connector:"PubMed"} 등
- `value` (numeric)
- `ts` (timestamptz)

**인덱스**
- `metrics_timeseries(metric_name, ts desc)`

#### `alerts`
- `id` (uuid, pk)
- `severity` (text) // info, warning, critical
- `title` (text)
- `message` (text)
- `source` (text) // ingestion, run, pdf, system
- `related_entity_type` (text)
- `related_entity_id` (text)
- `status` (text) // open, acknowledged, resolved
- `created_at`, `updated_at`

---

### 1.7 비용/쿼터(운영 필수)

#### `usage_costs`
- `id` (bigserial, pk)
- `user_id` (uuid, fk)
- `run_id` (uuid, fk, nullable)
- `cost_type` (text) // llm_tokens, embeddings, storage, egress
- `units` (numeric)  // tokens, vectors, bytes 등
- `cost_usd` (numeric)
- `meta_json` (jsonb) // model, prompt_version 등
- `created_at`

#### `quotas`
- `id` (uuid, pk)
- `user_id` (uuid, fk)
- `monthly_run_limit` (int)
- `monthly_cost_limit_usd` (numeric)
- `is_blocked` (bool)
- `updated_at`

---

## 2. Backend (FastAPI) 구현 설계

### 2.1 폴더 구조(권장)
- `backend/`
  - `main.py`
  - `api/v1/`
    - `routers/`
      - `dashboard.py`
      - `connectors.py`
      - `staging.py`
      - `ingestion.py`
      - `runs.py`
      - `reports.py`
      - `catalog.py`
      - `normalization.py`
      - `evaluation.py`
      - `observability.py`
      - `alerts.py`
      - `users.py`
      - `billing.py`
      - `audit.py`
    - `schemas/` (pydantic)
    - `deps.py` (auth/db)
  - `services/`
    - `connectors/` (pubmed.py 등)
    - `staging/`
    - `normalization/`
    - `rag/`
    - `orchestrator/`
    - `reporting/` (json builder)
    - `pdf/` (renderer)
    - `storage/` (s3/supabase)
    - `metrics/`
  - `workers/`
    - `tasks.py` (queue tasks)
  - `db/`
    - `session.py`
    - `migrations/` (alembic)

### 2.2 인증/권한
- Admin 메뉴는 최소 RBAC 필요
- FastAPI dependency:
  - `get_current_user()`
  - `require_role("admin")`
- 모든 변경 작업(CREATE/UPDATE/DELETE/EXECUTE/RETRY/DOWNLOAD)은 `audit_logs` 기록

---

## 3. API 설계(메뉴별) — 실제 연동 가능한 수준

> 응답은 목록/상세 + 액션(실행/재시도/다운로드/활성화) 4종 패턴을 표준화한다.

### 3.1 대시보드
- `GET /api/v1/admin/dashboard/summary`
  - returns: 오늘 KPI, 실패 Top, 큐 적체, 비용
- `GET /api/v1/admin/dashboard/actions`
  - returns: 즉시 조치 리스트(재시도 대상 등)

### 3.2 커넥터
- `GET /api/v1/admin/connectors`
- `POST /api/v1/admin/connectors`
- `GET /api/v1/admin/connectors/{id}`
- `PATCH /api/v1/admin/connectors/{id}` (enable/disable, config)
- `POST /api/v1/admin/connectors/{id}/run`
  - body: `{ input_json }`
  - effect: `connector_runs` 생성 후 worker enqueue

### 3.3 스테이징
- `GET /api/v1/admin/staging/documents?status=staged&limit=50`
- `GET /api/v1/admin/staging/documents/{id}`
- `POST /api/v1/admin/staging/documents/{id}/reprocess`
  - effect: normalization 재시도 큐

### 3.4 데이터 수집(파이프라인 실행/현황)
- `GET /api/v1/admin/ingestion/runs?status=running`
  - maps to `connector_runs`
- `GET /api/v1/admin/ingestion/runs/{id}`
- `POST /api/v1/admin/ingestion/runs/{id}/retry`

### 3.5 Runs (설계/오케스트레이터)
- `POST /api/v1/design/runs`
  - body: `{ run_type, input_json }`
  - effect: `design_runs` 생성, status=queued, worker enqueue
- `GET /api/v1/design/runs?status=done&limit=50`
- `GET /api/v1/design/runs/{id}`
- `GET /api/v1/design/runs/{id}/progress`
- `POST /api/v1/design/runs/{id}/retry`
- `POST /api/v1/design/runs/{id}/cancel`

### 3.6 리포트(템플릿/출력)
- `GET /api/v1/admin/report-templates?run_type=adc_candidate_report`
- `POST /api/v1/admin/report-templates`
- `PATCH /api/v1/admin/report-templates/{id}` (activate/deactivate)
- `GET /api/v1/design/runs/{id}/report`
  - returns: report_json summary + quality metrics
- `GET /api/v1/design/runs/{id}/pdf`
  - returns: presigned url 또는 바이너리 스트림
- `GET /api/v1/design/runs/{id}/artifacts`

### 3.7 카탈로그(Seed/Gold)
- `GET /api/v1/admin/catalog/entities?entity_type=payload`
- `POST /api/v1/admin/catalog/entities`
- `PATCH /api/v1/admin/catalog/entities/{id}`
- `POST /api/v1/admin/catalog/seed-sets/{id}/run-ingestion` (Seed 기반 수집 실행)

### 3.8 정규화/엔티티
- `GET /api/v1/admin/normalization/rules`
- `POST /api/v1/admin/normalization/rules`
- `PATCH /api/v1/admin/normalization/rules/{id}`
- `POST /api/v1/admin/normalization/resolve` (테스트 엔드포인트: 텍스트 넣고 어떤 엔티티로 매핑되는지)

### 3.9 품질/평가(Eval)
- `GET /api/v1/admin/evaluation/summary`
- `POST /api/v1/admin/evaluation/run` (골든셋 회귀 실행 → 결과 저장)
- `GET /api/v1/admin/evaluation/runs`
- `GET /api/v1/admin/evaluation/runs/{id}`

### 3.10 관측성/알림
- `GET /api/v1/admin/observability/metrics?metric_name=run_success_rate`
- `GET /api/v1/admin/alerts?status=open`
- `POST /api/v1/admin/alerts/{id}/ack`
- `POST /api/v1/admin/alerts/{id}/resolve`

### 3.11 사용자/권한/비용/감사로그
- `GET /api/v1/admin/users`
- `PATCH /api/v1/admin/users/{id}/roles`
- `GET /api/v1/admin/billing/usage?range=7d`
- `PATCH /api/v1/admin/billing/quotas/{user_id}`
- `GET /api/v1/admin/audit-logs?entity_type=run&limit=100`

---

## 4. Worker/Job 구현(실행 파이프라인)

### 4.1 Ingestion Job (커넥터 실행)
**Task:** `run_connector(connector_run_id)`
1) `connector_runs.status=running`
2) 외부 소스 호출 → raw 결과 수집
3) `staging_documents` upsert (unique source)
4) stats 업데이트 → succeeded/failed
5) 후속 작업 enqueue: `normalize_staging_documents(connector_run_id)`

### 4.2 Normalization + Indexing Job
**Task:** `normalize_staging_documents(connector_run_id)`
1) staged 문서 로드
2) `normalization_rules` 적용 + 엔티티 리졸브
3) `corpus_documents` upsert
4) 청킹 → `corpus_chunks` 저장 + 임베딩 저장
5) staging 상태 업데이트(normalized 또는 rejected)
6) metrics 기록

### 4.3 Orchestrator Run Job (보고서 생성)
**Task:** `execute_design_run(run_id)`
- 상태: queued → retrieving → structuring → writing → qa → rendering → done

**Round 1 (Evidence Harvest)**
- RAG 검색(하이브리드) → `evidences` 생성(E-000001…)
- `run_steps` 기록(metrics: evidence_count)

**Round 2 (Structuring & Scoring)**
- evidence를 ADC 스키마로 정규화(후보 조합/표적 비교/리스크)
- `report_json` 초안 생성

**Round 3 (Composition & QA)**
- Claim–Evidence 연결 강제(미연결 claim 제거/보정)
- QA/RedTeam: 수치 충돌/과장/근거 누락 검출 → 수정
- 품질 지표 계산: `claim_evidence_rate`, `assumption_count`

**PDF Rendering**
- 템플릿(`report_templates.is_active=true`) 로드
- `report_json` → PDF
- `report_artifacts`에 pdf 저장

---

## 5. PDF 출력 구현 스펙(필수 기능)

### 5.1 PDF 구성(제출형)
- 표지 + 목차
- Executive Summary
- Target Landscape (표 + 근거 링크)
- Design Candidates
  - 후보별 “카드(요약)” + “상세(근거 포함)”
- Risk Register (표)
- Experiment Plan (체크리스트)
- Evidence Index (Evidence ID ↔ 출처/위치)
- Query Log / Assumptions
- Appendix (용어사전/룰/가중치)

### 5.2 구현 제약(운영 안정성)
- 표는 페이지 자동 분할 + 헤더 반복
- Evidence 발췌는 짧게(저작권 리스크 최소화)
- PDF 렌더 실패 시: `design_runs.status=failed` + `alerts` 생성

---

## 6. Admin UI 연동 설계(Next.js)

### 6.1 라우트(권장)
- `/admin/dashboard`
- `/admin/connectors`
- `/admin/staging`
- `/admin/ingestion`
- `/admin/runs`
- `/admin/reports` (템플릿 + 출력물)
- `/admin/catalog`
- `/admin/normalization`
- `/admin/evaluation`
- `/admin/observability`
- `/admin/alerts`
- `/admin/users`
- `/admin/billing`
- `/admin/audit`

### 6.2 리스트 공통 컴포넌트 규칙
- 상단: 필터(상태/기간/타입) + 검색
- 테이블: 상태 배지 + 주요 메트릭 + 액션 버튼(상세/재시도/다운로드)
- 상세: 탭(Overview / Logs / Artifacts / Audit)

### 6.3 API 호출 규칙
- 모든 호출은 `/api/v1/...`
- 목록은 pagination 표준화: `?limit=50&cursor=...`
- 에러는 알림 시스템과 연결(사용자 표시 + 서버 alerts 생성)

---

## 7. 마이그레이션/개발 순서(현실적인 작업 티켓)

### Phase 1: 기반(필수)
1. Alembic 세팅 + 위 테이블 전부 생성
2. RBAC 기본(roles/user_roles)
3. audit_logs 자동 기록 미들웨어/서비스 구현

### Phase 2: 기존 메뉴 5개를 “실제로 동작”시키기
4. connectors CRUD + connector_runs 실행/재시도
5. staging 목록/상세/리프로세스
6. ingestion runs 상태/로그/통계
7. observability 최소 metrics_timeseries 기록 + 조회
8. alerts open/ack/resolve

### Phase 3: 제품 코어(보고서) 연결
9. design_runs 생성/상태/progress
10. orchestrator worker + run_steps/evidences/reports 저장
11. PDF 렌더 + report_artifacts 다운로드

### Phase 4: 추가 메뉴(운영 완성)
12. report_templates CRUD + 활성화/버전
13. catalog/entities CRUD + seed 기반 수집 트리거
14. normalization rules CRUD + resolve 테스트
15. evaluation 골든셋/회귀 실행
16. billing/quotas/usage_costs 집계
17. audit 화면 구성

---

## 8. 완료 기준(Definition of Done)

- Admin에서 커넥터 실행 → 스테이징 적재 → 정규화/인덱싱 완료까지 상태가 추적됨
- Admin에서 Design Run 생성 → progress 확인 → report.json 조회 → PDF 다운로드가 가능
- 실패 케이스에서 alerts가 생성되고, 재시도 버튼이 동작
- 모든 변경/실행이 audit_logs에 남음
- 비용/사용량이 사용자별로 집계됨(최소 llm_tokens/embeddings)

---

## 9. 체크리스트(실수 방지)

- [ ] `source_type + source_uid` 유니크로 중복 적재 방지
- [ ] 모든 Run/Job 실패는 `error_json` + `alerts` 생성
- [ ] 모든 핵심 claim에는 evidence_id 연결(미연결은 “가정”으로 분리)
- [ ] PDF 부록이 커져도 렌더가 깨지지 않게 페이지 분할 적용
- [ ] 템플릿 버전 변경 시 기존 보고서 재현 가능(템플릿 버전 저장)

---

## 10. 바로 다음 액션(권장)

1) DB 마이그레이션(Alembic)로 1.2~1.7 테이블 생성  
2) `/api/v1/admin/connectors` + `/api/v1/admin/ingestion` + 워커 `run_connector()` 먼저 구현  
3) 다음으로 `/api/v1/design/runs` + `execute_design_run()` + PDF 렌더까지 연결  
4) Admin Dashboard는 위 API를 합쳐 KPI/액션센터부터 구성

---
