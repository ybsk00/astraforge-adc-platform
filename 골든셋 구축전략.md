# 골든셋 100개 자동화 (자동 생성 → 자동 검증 게이트 → DB 자동 적재) 실행 가능한 설계 MD (v1)

목표
- “표적/항체/링커/페이로드”가 포함된 **ADC Golden Set 100개**를 사람이 수작업으로 입력하지 않고,
- 커넥터 실행(Run) 버튼을 누르면 **자동으로 후보 수집 → 구성요소 추출/표준화 → 교차근거 기반 자동 검증 → 상위 100개 선정 → DB Upsert**까지 수행되게 한다.
- 이후 모델 검증 시 **Golden Data(정답)** vs **모델 예측**을 비교하여 `golden_validation_runs / golden_validation_metrics`에 자동 기록한다.

---

## 1) 전제: 현재 시스템에서 “Run(커넥터 실행)”이 동작하는 방식
- 프론트/Next API Route가 **connector_runs** 테이블에 `status='queued'` 작업을 INSERT 한다.
- 파이썬 워커가 `connector_runs`를 폴링(또는 락 기반 pickup)하여 `running → succeeded/failed`로 상태를 변경한다.
- 결과 요약은 `result_summary`, 에러는 `error_json`에 저장한다.

이 골격은 그대로 사용하고, **Golden Set 생성도 하나의 커넥터(Connector)** 로 취급한다.

---

## 2) DB 엔티티 구조 (Golden Data + Validation History + Run Queue)

### 2.1 Golden Data (정답 데이터)
#### A) golden_candidates (골든 후보/정답 케이스)
- id (PK, uuid)
- drug_name (text) : 예) Kadcyla, Enhertu
- target (text) : 예) HER2
- antibody (text)
- linker (text)
- payload (text)
- approval_status (text) : approved / late_stage / clinical / preclinical
- source_ref (text) : DOI / NCT / 특허번호 등 핵심 근거 ID
- confidence_score (int) : 자동 검증 점수(0~100)
- created_at, updated_at

#### B) golden_measurements (골든 실험값)
- id (PK)
- candidate_id (FK -> golden_candidates.id)
- metric_name (text) : IC50, Aggregation_pct 등
- value (numeric)
- unit (text)
- assay_type (text)
- condition (text)
- quality_flag (text) : ok / estimated
- source_ref (text) : PMID/DOI/Patent 등
- created_at

> v1에서는 “구성요소 4개 + 근거” 중심으로 먼저 100개를 만들고,
> 측정값(golden_measurements)은 **2단계**로 확장(문헌 파싱/수동 보강)해도 됩니다.

### 2.2 Validation History (검증 이력)
#### C) golden_validation_runs
- id (PK)
- dataset_version (text)
- model_version (text)
- pass (boolean)
- summary (jsonb) : overall 및 축별 요약
- created_at

#### D) golden_validation_metrics
- id (PK)
- run_id (FK -> golden_validation_runs.id)
- axis (text) : Bio / Safety / Eng / Clin / Overall
- metric (text) : MAE, Spearman, RMSE 등
- value (numeric)
- pass (boolean)

### 2.3 Run Queue (이미 존재)
#### E) connector_runs (작업 큐)
- id (uuid)
- connector_id (uuid)
- status (text) : queued/running/succeeded/failed
- attempt (int)
- result_summary (jsonb)
- error_json (jsonb)
- locked_by (text)
- locked_at (timestamptz)
- created_at

---

## 3) 핵심 아이디어: “골든셋 생성”을 커넥터로 만든다
- connectors 테이블(이미 존재한다고 가정)에 `GOLDEN_SEED_ADC_100` 커넥터를 추가한다.
- 사용자가 Admin UI에서 이 커넥터를 Run하면, 워커가 아래 파이프라인을 수행한다.

### 커넥터 파이프라인(자동)
1) 후보 수집(ClinicalTrials 등) → 300~1000개
2) 텍스트에서 구성요소 추출(Target/Antibody/Linker/Payload)
3) 표준화(Normalization)
4) 자동 검증 게이트(Quality Gate) 통과한 케이스만 남김
5) confidence_score 기준 상위 100개 선정
6) DB Upsert로 golden_candidates에 적재
7) connector_runs.result_summary에 결과 기록

---

## 4) 자동 “검증된 100개”의 정의(자동 검증 게이트)
“검증된”을 사람이 확인했다는 뜻이 아니라,
**여러 출처의 교차근거 및 표준화 성공을 통과한 고신뢰 데이터**라는 의미로 정의한다.

### 4.1 필수 통과 조건 (Hard Gate)
- (G1) target/antibody/linker/payload 4요소 모두 추출됨
- (G2) payload가 내부 표준 사전(payload_dictionary)에 매핑됨 (예: MMAE, DM1, DXd, SN-38, PBD 등)
- (G3) linker가 내부 표준 사전(linker_dictionary)에 매핑됨 (예: VC, SMCC, non-cleavable 등)
- (G4) evidence 최소 2개 이상
  - 예: NCT + PMID, 또는 PMID 2개, 또는 NCT + 특허번호

### 4.2 신뢰도 점수 (Soft Score, 0~100)
- +30: 임상시험(NCT) 존재
- +20: PMID 1개 이상
- +10: PMID 2개 이상
- +15: approval_status가 approved/late_stage
- +10: target 표준화 성공(예: UniProt/HGNC 매핑) *v2에서 확장
- -20: 구성요소 중 1개라도 “추정/불명확” 플래그 존재

상위 100개를 점수 내림차순으로 선택한다.

---

## 5) 구현 파일(권장) — 실제로 돌아가게 만드는 최소 셋

### 5.1 SQL Migration (v1)
파일: `supabase/migrations/YYYYMMDDHHMM_add_golden_tables.sql`

```sql
-- golden_candidates
create table if not exists golden_candidates (
  id uuid primary key default gen_random_uuid(),
  drug_name text not null,
  target text not null,
  antibody text not null,
  linker text not null,
  payload text not null,
  approval_status text default 'clinical',
  source_ref text,
  confidence_score int default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),
  unique(drug_name, target, antibody, linker, payload)
);

-- golden_measurements
create table if not exists golden_measurements (
  id uuid primary key default gen_random_uuid(),
  candidate_id uuid not null references golden_candidates(id) on delete cascade,
  metric_name text not null,
  value numeric,
  unit text,
  assay_type text,
  condition text,
  quality_flag text default 'ok',
  source_ref text,
  created_at timestamptz default now()
);

-- golden_validation_runs
create table if not exists golden_validation_runs (
  id uuid primary key default gen_random_uuid(),
  dataset_version text not null,
  model_version text not null,
  pass boolean default false,
  summary jsonb default '{}'::jsonb,
  created_at timestamptz default now()
);

-- golden_validation_metrics
create table if not exists golden_validation_metrics (
  id uuid primary key default gen_random_uuid(),
  run_id uuid not null references golden_validation_runs(id) on delete cascade,
  axis text not null,
  metric text not null,
  value numeric,
  pass boolean default false,
  unique(run_id, axis, metric)
);

-- updated_at trigger(선택)
create or replace function set_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

drop trigger if exists golden_candidates_set_updated_at on golden_candidates;
create trigger golden_candidates_set_updated_at
before update on golden_candidates
for each row execute function set_updated_at();
5.2 Connector 정의(시드)
connectors 테이블이 있다면, 아래와 같이 1개 레코드 추가 (컬럼명은 프로젝트에 맞춰 조정)

sql
코드 복사
-- 예시: connectors(name, type, config_json)
insert into connectors(name, type, config_json)
values (
  'GOLDEN_SEED_ADC_100',
  'golden_seed',
  jsonb_build_object(
    'target_count', 100,
    'candidate_fetch_size', 500,
    'sources', jsonb_build_array('clinicaltrials','pubmed'),
    'min_evidence', 2
  )
)
on conflict (name) do nothing;
6) Next.js API Route: Run 버튼 클릭 시 queued 생성
파일: app/api/admin/connectors/run/route.ts (예시)

핵심

connector_id를 받아서 connector_runs에 INSERT(status=queued)

프론트는 이 API만 호출하면 됨 (백엔드 별도 URL 직접 호출 방지)

의사코드(구현은 프로젝트 supabase client에 맞춤):

ts
코드 복사
POST { connector_id }

1) insert into connector_runs(connector_id, status, attempt) values(connector_id, 'queued', 0)
2) return { run_id }
7) Python Worker: connector_runs에서 job pickup → 실행
워커는 “상시 실행 프로세스”여야 한다.

로컬: Docker Compose로 띄움

배포: VM/Render/Fly/Cloud Run(상시) 등 Vercel 밖에서 실행

7.1 안전한 Job pickup (원자적 락)
Postgres 권장 패턴: FOR UPDATE SKIP LOCKED

의사 로직

트랜잭션 시작

status='queued' 1개를 SKIP LOCKED로 가져오기

즉시 status='running', locked_by, locked_at 업데이트

커밋

실행

7.2 워커 엔트리
파일: services/worker/main.py (예시)

python
코드 복사
import os, time, json
from datetime import datetime
from supabase import create_client

SUPABASE_URL = os.environ["SUPABASE_URL"]
SUPABASE_SERVICE_ROLE_KEY = os.environ["SUPABASE_SERVICE_ROLE_KEY"]
WORKER_ID = os.environ.get("WORKER_ID", "worker-1")

sb = create_client(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY)

def pick_one_job():
    # NOTE: supabase-py가 raw SQL RPC를 지원하도록 구성하거나,
    # PostgREST RPC로 함수(pick_connector_run)를 만들어 호출하는 방식 권장.
    raise NotImplementedError

def update_run(run_id, **fields):
    sb.table("connector_runs").update(fields).eq("id", run_id).execute()

def run_loop():
    while True:
        job = pick_one_job()
        if not job:
            time.sleep(5)
            continue

        run_id = job["id"]
        connector_id = job["connector_id"]

        try:
            # 1) 커넥터 조회
            connector = sb.table("connectors").select("*").eq("id", connector_id).single().execute().data
            if connector["name"] == "GOLDEN_SEED_ADC_100":
                summary = execute_golden_seed(connector.get("config_json", {}), run_id)
            else:
                raise Exception(f"Unknown connector: {connector['name']}")

            update_run(run_id, status="succeeded", result_summary=summary)

        except Exception as e:
            update_run(run_id, status="failed", error_json={"message": str(e)})

        time.sleep(1)

if __name__ == "__main__":
    run_loop()
8) Golden Seed 실행 로직(핵심): 후보 수집 → 추출 → 표준화 → 게이트 → 상위 100 → Upsert
파일: services/worker/jobs/golden_seed_adc_100.py (예시)

8.1 사전(Dictionary) 준비 (링커/페이로드 표준화)
파일: services/worker/jobs/dictionaries.py

payload_dictionary (표준명 매핑)

"monomethyl auristatin E" → "MMAE"

"deruxtecan" → "DXd"

"emtansine" → "DM1"

linker_dictionary (표준명 매핑)

"valine-citrulline" → "VC"

"SMCC" → "SMCC"

"non-cleavable" → "NON_CLEAVABLE"

8.2 후보 수집 (ClinicalTrials 우선)
query.term=antibody-drug conjugate 등으로 500개 수집

intervention/description 텍스트를 저장

8.3 구성요소 추출 (규칙 + 보조)
우선: 정규식/키워드 기반

부족 시: LLM 보조(선택). 단, LLM 결과는 “정답”이 아니라 “추출 후보”로만 사용

추출 결과는 아래 구조로 통일

target, antibody, linker, payload, drug_name, approval_status, evidence_refs[]

8.4 자동 검증 게이트 적용
G1~G4 통과하지 못하면 버림

confidence_score 계산

8.5 상위 100개 선정
score 내림차순, 동점은 drug_name 알파벳 정렬로 결정(결정적 재현성)

8.6 DB Upsert
golden_candidates unique(drug_name,target,antibody,linker,payload) 기반 upsert

source_ref는 대표 근거(NCT 또는 PMID)로 저장

confidence_score 저장

8.7 결과 요약(result_summary) 예시
json
코드 복사
{
  "created": 83,
  "updated": 17,
  "total_selected": 100,
  "source_counts": {"clinicaltrials": 100, "pubmed": 68},
  "avg_confidence_score": 78,
  "elapsed_sec": 142
}
9) “검증된 100개를 자동으로 DB에 넣는 방법”의 정확한 의미
이 설계에서 “검증된 100개”란:

최소 2개 출처의 교차근거 + 표준 사전 매핑 + 4요소 완비
를 통과한 고신뢰 자동 골든셋이다.

추가로 “사람 검수까지 포함한 완전 검증”을 원하면 v1.1로 확장:

golden_candidates에 review_status (pending/approved/rejected) 추가

자동 생성은 pending으로 넣고, 관리자 승인 후 approved만 골든셋으로 사용

10) 운영/배포 체크리스트
Vercel: UI + API Route(queued insert)만 담당

Worker: Vercel 밖에서 상시 실행 (Docker/VM/Render/Fly 등)

Supabase: DB 및 connector_runs 큐 역할

환경변수(Worker)

SUPABASE_URL

SUPABASE_SERVICE_ROLE_KEY

WORKER_ID

11) 1회 실행 절차(로컬)
Supabase에 migration 적용

connectors에 GOLDEN_SEED_ADC_100 등록

Worker 실행(로컬)

Admin UI에서 GOLDEN_SEED_ADC_100 커넥터 Run 클릭

connector_runs가 queued → running → succeeded

golden_candidates에 100개 upsert 확인

검증 쿼리

sql
코드 복사
select count(*) from golden_candidates;
12) 다음 단계(v2 권장)
target 표준화: UniProt/HGNC 매핑 컬럼 추가 (target_id)

antibody/linker/payload도 내부 catalog 테이블과 FK 연결 (정규화)

golden_measurements 자동 수집: DOI/PMID 기반 테이블 파싱(부분 자동 + 관리자 보강)

validation 자동화: 모델 예측 결과 테이블과 join하여 MAE/Spearman 계산 후 golden_validation_*에 저장

부록 A) pick_one_job RPC(권장)
Supabase(PostgREST) 환경에서 “원자적 락 pickup”을 안정적으로 하려면
DB에 RPC 함수를 만들어 호출하는 방식을 권장한다.

예: pick_connector_run(worker_id text) 함수가

queued 1개를 SKIP LOCKED로 잡고 running으로 바꾼 후

해당 레코드를 반환하도록 구현

(이 RPC는 실제 구현 시 제공 가능)

yaml
코드 복사

--- 

원하시면, 위 MD를 **당신 레포의 실제 파일 경로/테이블 컬럼명**에 1:1로 맞춰서,
- `pick_connector_run()` RPC SQL
- `execute_golden_seed()` 실제 파이썬 코드(ClinicalTrials 호출 + 파싱 + 게이트 + upsert)
- Next API Route의 실제 Supabase 호출 코드
까지 “복붙하면 바로 실행되는 형태”로 구체화해드릴 수 있습니다.
::contentReference[oaicite:0]{index=0}





